package com.cratediggers.entity;

import java.util.Base64;
import java.util.Comparator;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import static javax.persistence.GenerationType.IDENTITY;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQueries;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import javax.persistence.UniqueConstraint;

/**
 * Album entity class maps to database, can be interacted with by an EntityManager object. 
 */
@SuppressWarnings("serial")
@Entity
@Table(name = "album", catalog = "prototype", uniqueConstraints = { @UniqueConstraint(columnNames = "title") })
@NamedQueries({
	@NamedQuery(name = "Album.findAll", query = "SELECT a FROM Album a"),
	@NamedQuery(name = "Album.findByTitle", query = "SELECT a FROM Album a WHERE a.title = :title"),
	@NamedQuery(name = "Album.countAll", query = "SELECT COUNT(*) FROM Album a"),
	@NamedQuery(name = "Album.countByGenre", query = "SELECT COUNT(a) FROM Album a "
			+ "WHERE a.genre.genreId = :genId"),
	@NamedQuery(name = "Album.countByArtist", query = "SELECT COUNT(a) FROM Album a "
			+ "WHERE a.artist.artistId = :artId"),
	@NamedQuery(name = "Album.findByGenre", query = "SELECT a FROM Album a JOIN "
			+ "Genre g ON a.genre.genreId = g.genreId AND g.genreId = :genId"),
	@NamedQuery(name = "Album.listNew", query = "SELECT a FROM Album a ORDER BY a.release"
			+ "Date DESC"),
	@NamedQuery(name = "Album.search", query = "SELECT a FROM Album a WHERE a.title LIKE '%' || :keyword || '%'"
			+ " OR a.artist LIKE '%' || :keyword || '%'"
			+ " OR a.description LIKE '%' || :keyword || '%'")
})
public class Album implements java.io.Serializable {

	/**
	 * Id of an album object.
	 * Auto-incremented.
	 */
	private Integer albumId;
	/**
	 * Artist which album object belongs to (according to foreign key).
	 */
	private Artist artist;
	/**
	 * Genre which album object belongs to (according to foreign key).
	 */
	private Genre genre;
	/**
	 * Title of an album object.
	 */
	private String title;
	/**
	 * Description of an album object.
	 */
	private String description;
	/**
	 * Image of an album object's cover art.
	 */
	private byte[] image;
	/**
	 * Image of an album object's cover art in base64 form for display on JSP pages.
	 */
	private String base64Image;
	/**
	 * Price of an album.
	 */
	private float price;
	/**
	 * Release date of an album.
	 */
	private Date releaseDate;
	/**
	 * Time that album record was last updated.
	 */
	private Date lastUpdateTime;
	/**
	 * Set of reviews in relational database that contain albumId.
	 */
	private Set<Review> reviews = new HashSet<Review>(0);
	/**
	 * Set of orders in relational database that contain albumId.
	 */
	private Set<OrderDetail> orderDetails = new HashSet<OrderDetail>(0);

	/**
	 * Constructs empty album entity object.
	 */
	public Album() {
	}
	
	/**
	 * Constructs an album entity object only with albumId.
	 * @param albumId
	 */
	public Album(Integer albumId) {
		super();
		this.albumId = albumId;
	}

	/**
	 * Constructs an album entity object without albumId.
	 * albumId can be generated by database auto-increment.
	 * @param artist
	 * @param genre
	 * @param title
	 * @param description
	 * @param image
	 * @param price
	 * @param releaseDate
	 * @param lastUpdateTime
	 */
	public Album(Artist artist, Genre genre, String title, String description, byte[] image, float price,
			Date releaseDate, Date lastUpdateTime) {
		this.artist = artist;
		this.genre = genre;
		this.title = title;
		this.description = description;
		this.image = image;
		this.price = price;
		this.releaseDate = releaseDate;
		this.lastUpdateTime = lastUpdateTime;
	}
	
	/**
	 * Constructs an album entity object without albumId but with set of reviews / orders.
	 * albumId can be generated by database auto-increment.
	 * @param genre
	 * @param title
	 * @param artist
	 * @param description
	 * @param image
	 * @param price
	 * @param releaseDate
	 * @param lastUpdateTime
	 * @param reviews
	 * @param orderDetails
	 */
	public Album(Genre genre, String title, Artist artist, String description, byte[] image,
			float price, Date releaseDate, Date lastUpdateTime, Set<Review> reviews, Set<OrderDetail> orderDetails) {
		this.genre = genre;
		this.title = title;
		this.artist = artist;
		this.description = description;
		this.image = image;
		this.price = price;
		this.releaseDate = releaseDate;
		this.lastUpdateTime = lastUpdateTime;
		this.reviews = reviews;
		this.orderDetails = orderDetails;
	}

	/**
	 * albumId getter method.
	 * @return albumId of album object
	 */
	@Id
	@GeneratedValue(strategy = IDENTITY)

	@Column(name = "album_id", unique = true, nullable = false)
	public Integer getAlbumId() {
		return this.albumId;
	}

	/**
	 * albumId setter method.
	 * @param albumId
	 */
	public void setAlbumId(Integer albumId) {
		this.albumId = albumId;
	}

	/**
	 * artist getter method.
	 * artist object retrieved from database according to foreign key.
	 * @return artist of an album object
	 */
	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "artist_id", nullable = false)
	public Artist getArtist() {
		return this.artist;
	}

	/**
	 * artist setter method.
	 * @param artist
	 */
	public void setArtist(Artist artist) {
		this.artist = artist;
	}

	/**
	 * genre getter method.
	 * genre object retrieved from database according to foreign key.
	 * @return genre of an album object
	 */
	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "genre_id", nullable = false)
	public Genre getGenre() {
		return this.genre;
	}

	/**
	 * genre setter method.
	 * @param genre
	 */
	public void setGenre(Genre genre) {
		this.genre = genre;
	}

	/**
	 * title getter method.
	 * @return title of an album object
	 */
	@Column(name = "title", unique = true, nullable = false, length = 128)
	public String getTitle() {
		return this.title;
	}

	/**
	 * title setter method.
	 * @param title
	 */
	public void setTitle(String title) {
		this.title = title;
	}

	/**
	 * description getter method.
	 * @return description of an album object
	 */
	@Column(name = "description", nullable = false, length = 16777215)
	public String getDescription() {
		return this.description;
	}

	/**
	 * description setter method.
	 * @param description
	 */
	public void setDescription(String description) {
		this.description = description;
	}

	/**
	 * image getter method.
	 * @return image of an album object
	 */
	@Column(name = "image", nullable = false)
	public byte[] getImage() {
		return this.image;
	}

	/**image setter method.
	 * @param image
	 */
	public void setImage(byte[] image) {
		this.image = image;
	}

	/**
	 * price getter method.
	 * @return price of an album object
	 */
	@Column(name = "price", nullable = false, precision = 12, scale = 0)
	public float getPrice() {
		return this.price;
	}

	/**
	 * price setter method.
	 * @param price
	 */
	public void setPrice(float price) {
		this.price = price;
	}

	/**
	 * releaseDate getter method.
	 * @return releaseDate of an album object
	 */
	@Temporal(TemporalType.DATE)
	@Column(name = "release_date", nullable = false, length = 10)
	public Date getReleaseDate() {
		return this.releaseDate;
	}

	/**
	 * releaseDate setter method.
	 * @param releaseDate
	 */
	public void setReleaseDate(Date releaseDate) {
		this.releaseDate = releaseDate;
	}

	/**
	 * lastUpdateTime getter method.
	 * @return lastUpdateTime of an album object
	 */
	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "last_update_time", nullable = false, length = 19)
	public Date getLastUpdateTime() {
		return this.lastUpdateTime;
	}

	/**
	 * lastUpdateTime setter method.
	 * @param lastUpdateTime
	 */
	public void setLastUpdateTime(Date lastUpdateTime) {
		this.lastUpdateTime = lastUpdateTime;
	}
	
	/**
	 * Converts image of an album object to base64 string.
	 * @return base64Image of an album object
	 */
	@Transient
	public String getBase64Image() {
		this.base64Image = Base64.getEncoder().encodeToString(this.image);
		return this.base64Image;
	}
	
	/**
	 * base64Image setter method.
	 * @param base64Image
	 */
	@Transient
	public void setBase64Image(String base64Image) {
		this.base64Image = base64Image;
	}
	
	/**
	 * reviews getter method.
	 * Sorts the set based on reviewTime.
	 * @return reviews of an album object
	 */
	@OneToMany(fetch = FetchType.EAGER, mappedBy = "album")
	public Set<Review> getReviews() {
		TreeSet<Review> sortedReviews = new TreeSet<>(new Comparator<Review>() {
			/**
			 * Overrides TreeSet comparator method so that reviews are sorted according to reviewTime.
			 * @param review1 the first review to be compared
			 * @param review2 the second review to be compared
			 * @return the value 0 if the reviewDate of review1 is equal to the reviewDate of review2; 
			 * a value less than 0 if the reviewDate of review1 is before the reviewDate of review2; 
			 * and a value greater than 0 if reviewDate of review1 is after the reviewDate of review2. 
			 */
			@Override
			public int compare(Review review1, Review review2) {
				return review2.getReviewTime().compareTo(review1.getReviewTime());
			}
			
		});
		
		sortedReviews.addAll(reviews);
		return sortedReviews;
	}

	/**
	 * reviews setter method
	 * @param reviews
	 */
	public void setReviews(Set<Review> reviews) {
		this.reviews = reviews;
	}

	/**
	 * orderDetails getter method
	 * retrieves from orderDetail table using to foreign keys
	 * @return orderDetails of an album object
	 */
	@OneToMany(fetch = FetchType.EAGER, mappedBy = "album")
	public Set<OrderDetail> getOrderDetails() {
		return this.orderDetails;
	}

	/**
	 * orderDetails setter method
	 * @param orderDetails
	 */
	public void setOrderDetails(Set<OrderDetail> orderDetails) {
		this.orderDetails = orderDetails;
	}

	/**
	 * Calculates average rating across all reviews of an album object
	 * @return Average rating 
	 */
	@Transient
	public float getAverageRating() {
		float averageRating = 0.0f;
		float sum = 0.0f;
		
		if (reviews.isEmpty()) {
			return 0.0f;
		}
		
		for (Review review : reviews) {
			sum += review.getRating();
		}
		
		averageRating = sum / reviews.size();
		
		return averageRating;
	}
	
	/**
	 * Calculates average rating of an album object and returns the result in string format to display rating using stars in JSP files.
	 * @return String containing "on", "half" or "off" instructions
	 */
	@Transient
	public String getRatingStars() {
		float averageRating = getAverageRating();
		
		return getRatingString(averageRating);
	}
	
	/**
	 * Parses average rating float value into string that can be used by JSP pages to represent ratings using stars.
	 * "on" denotes a full star, "half" denotes a half star, and "off" denotes no star should be displayed.
	 * @param averageRating of an album object
	 * @return String containing "on", "half" or "off" instructions
	 */
	@Transient
	public String getRatingString(float averageRating) {
		String result = "";
		
		int numberOfStarsOn = (int) averageRating;
		
		for (int i = 1; i <= numberOfStarsOn; i++) {
			result += "on,";
		}
		
		int next = numberOfStarsOn + 1;
		
		if (averageRating > numberOfStarsOn) {
			result += "half,";
			next++;
		}
		
		for (int j = next; j <= 5; j++) {
			result += "off,";
		}
		
		return result.substring(0, result.length() - 1);
	}
	
	/**
	 * Generates unique integer identifier of an Album object.
	 * Used to compare to objects to check if they are the same.
	 * @return Unique hash-code of object based on albumId.
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((albumId == null) ? 0 : albumId.hashCode());
		return result;
	}

	/**
	 * Overrides equals method.
	 * Checks if an album object is identical to another object.
	 * @param obj to be compared to
	 * @return true if the object are the same; false if not.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Album other = (Album) obj;
		if (albumId == null) {
			if (other.albumId != null)
				return false;
		} else if (!albumId.equals(other.albumId))
			return false;
		return true;
	}
	
	@Transient
	public int getSales() {
		int total = 0;
		Set<OrderDetail> orderDetails = getOrderDetails();
		Iterator<OrderDetail> iterator = orderDetails.iterator();
		while (iterator.hasNext()) {
			total += iterator.next().getQuantity();
		}
		return total;
	}

}
